# 15장 구글 드라이브: 파일 저장 및 동기화 서비스

알림 서비스(Notifications)는 구글 드라이브 같은 동기화 시스템에서 “변경 사실을 빠르게 전파”해 동기화 지연과 충돌 확률을 낮추는 핵심 컴포넌트다. 특히 사용자가 파일을 업로드/편집/삭제하거나 공유 범위가 바뀌는 순간, 다른 단말이 즉시 이를 인지하고 메타데이터를 재조회한 뒤 필요한 블록만 내려받아 파일을 재구성할 수 있어야 한다. 본 설계에서는 알림 빈도가 채팅처럼 매우 높지 않고, 양방향 상시 스트리밍이 필수는 아니므로 롱 폴링(long polling) 방식을 기본으로 채택한다. 각 클라이언트는 알림 서버와 연결을 유지하고, 변경 이벤트가 발생하면 서버가 응답을 반환하면서 연결을 종료한다. 클라이언트는 곧바로 API 서버를 통해 최신 메타데이터를 가져오고(필요 시 다운로드 수행), 다시 알림 서버에 롱 폴링 연결을 재수립한다.

다만 대규모 서비스에서 알림 서비스의 장애는 “기능 자체의 복잡성”보다 연결 모델의 특성 때문에 복구가 느려질 수 있다. 알림 서버 한 대가 수십만~백만 단위의 롱 폴링 연결을 유지하는 것은 가능하지만, 서버 장애로 연결이 끊어지면 해당 사용자들이 동시에 재연결을 시도하게 된다. 이때 발생하는 핸드셰이크/인증/세션 생성/커널 리소스 할당 비용이 순간적으로 집중되며, 로드밸런서와 알림 서버로 **재연결 폭주(thundering herd)**가 유입된다. 결과적으로 “서버 프로세스는 다시 올라왔는데 사용자가 정상 상태로 돌아오는 데 시간이 걸리는” 현상이 나타나며, 이는 알림 지연 → 동기화 지연 → 충돌 가능성 증가로 이어질 수 있다. 따라서 알림 장애 대응은 단순히 서버를 다중화하는 수준을 넘어, 재연결 폭주를 제어하고 오프라인 사용자에게도 이벤트를 안전하게 전달하는 구조가 필요하다.

우선 알림 서비스는 수평 확장 가능한 다중 인스턴스 구조로 구성한다. 로드밸런서는 알림 서버들의 헬스 체크를 지속 수행하여 비정상 인스턴스를 즉시 격리하고, 살아있는 인스턴스로 트래픽을 우회시킨다. 또한 알림 서버 자체는 가급적 무상태(stateless) 로 유지해 인스턴스 교체 비용을 낮춘다. 즉, “어떤 파일을 구독 중인지” 같은 상태를 알림 서버 프로세스의 메모리에만 두지 않고, 클라이언트가 재연결 시점에 자신이 알고 있는 마지막 동기화 지점(예: 마지막으로 처리한 이벤트의 커서/버전/타임스탬프) 을 함께 전달해 복원할 수 있게 한다. 이 방식은 장애 시 인스턴스가 바뀌더라도 구독 상태를 쉽게 복구할 수 있고, 롤링 배포나 오토스케일링 과정에서도 안정적으로 동작한다.

다음으로, 재연결 폭주를 완화하기 위한 클라이언트 측 및 서버 측 제어가 필수다. 클라이언트는 알림 연결이 끊겼을 때 즉시 무한 재시도를 수행하지 않고, 지수 백오프(exponential backoff) 와 랜덤 지터(jitter) 를 적용해 재연결 시점을 분산시킨다. 이를 통해 “모두가 같은 순간에 다시 붙는” 상황을 피하고, 서버가 점진적으로 연결을 수용할 수 있다. 서버/로드밸런서 측에서는 필요에 따라 연결 생성에 대한 레이트 리밋을 두어 급격한 연결 폭증이 다른 컴포넌트(API 서버, 인증 서버 등)로 전파되지 않도록 방어한다. 이런 보호 장치가 없으면, 알림 서버 장애가 곧바로 인증/메타데이터 DB의 과부하로 이어져 연쇄 장애로 확대될 수 있다.

또 하나의 핵심은 오프라인 사용자 처리다. 사용자가 접속 중일 때는 롱 폴링 연결을 통해 이벤트를 즉시 전달하면 되지만, 접속 중이 아닐 때는 “나중에 접속했을 때 알려주기 위한 장치”가 필요하다. 이를 위해 오프라인 사용자의 이벤트를 쌓아두는 백업 큐(offline backup queue) 를 두며, 이 큐는 반드시 다중화/샤딩되어야 한다. 만약 백업 큐가 단일 노드라면 큐 장애는 곧 오프라인 사용자 알림의 유실과 동일한 의미가 되어 SPOF가 된다. 따라서 큐는 복제 또는 파티셔닝을 통해 내구성을 확보하고, 알림 서버들은 장애 상황에서도 다른 파티션/복제본으로 구독 관계를 재설정할 수 있어야 한다. 즉, 특정 알림 서버가 죽어도 큐의 이벤트 자체는 보존되고, 다른 알림 서버가 이를 소비하면서 사용자가 다음에 접속했을 때 누락 없이 전달할 수 있어야 한다.

마지막으로, 이벤트 전달의 안정성을 위해 설계 전반에 멱등성(idempotency) 과 정합성 기준을 둔다. 알림은 “실제 데이터”가 아니라 “변경이 있었음”을 알리는 신호이며, 최종 진실은 메타데이터 DB(강한 일관성)와 블록 저장소(S3)에 있다. 따라서 알림이 중복되거나 일부 지연되더라도 클라이언트는 알림을 트리거로 메타데이터를 재조회하고, 파일 버전/블록 해시를 기반으로 필요한 작업만 수행하면 된다. 이때 클라이언트가 “마지막으로 처리한 이벤트 커서”를 저장해 두면, 재접속 시 서버는 그 이후의 이벤트만 전달할 수 있고, 설령 중복 전달이 발생해도 클라이언트는 커서/버전 비교로 안전하게 무시할 수 있다.

정리하면, 알림 서비스 장애는 단순히 서버가 죽는 문제가 아니라 동시 재연결 폭주와 오프라인 이벤트 보존이 복구 시간을 결정하는 문제다. 따라서 (1) 알림 서버 수평 확장 및 헬스 체크 기반 격리, (2) 무상태화와 커서 기반 재구독, (3) 백오프·지터·레이트리밋을 통한 재연결 폭주 제어, (4) 오프라인 백업 큐의 다중화와 구독 재설정 가능 구조를 함께 갖춰야 한다. 이렇게 설계하면 알림 서버 일부 장애가 발생하더라도 전체 시스템은 지속 동작하며, 사용자 관점에서 동기화 지연과 충돌 가능성을 최소화할 수 있다. 구독 관계를 재설정해야 한다.