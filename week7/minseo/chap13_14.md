# 13장. 검색어 자동완성 시스템
### 1단계 : 문제 이해 및 설계 범위 확정
### 2단계 : 개략적 설계안 제시 및 동의 구하기
  -  ```데이터 수집 서비스``` = 입력한 질의를 실시간으로 수집하는 시스템
  -  ```질의 서비스``` = 주엊진 질의에 다섯 개의 인기 검색어를 정렬해놓는 서비스
     - SQL 질의문 방식 -> 데이터가 많아지면 데이터베이스 병목 발생 가능성 존재 

### 3단계 : 상세 설계
1. **트라이 자료구조**
   - 트라이 = 문자열들을 간략하게 저장할 수 있는 트리 형태의 자료구조 
     - 루트 노드는 빈 문자열을 나타냄
     - 각 노드는 글자 하나를 지정하고 26개의 자식노드를 가질 수 있음 
     - 트리 노드는 하나의 단어, 또는 접두어 문자열로 나타냄

![alt text](/images/image.png)
- 이용 빈도에 따라 정렬된 결과를 내놓기 위해 노드에 빈도 정보까지 저장할 필요 O

```
p: 접두어의 길이
n: 트라이 안에 있는 노드의 개수
c: 주어진 노드의 자식 노드 개수
```

가장 많이 사용된 질의어 k개를 찾는 방법,
- 해당 접두어를 표현하는 노드를 찾는다 : **O(p)**
- 해당 노드부터 시작하는 하위 트리를 탐색하여 모든 유효 노드를 찾는다 : **O(c)**
- 유효 노드들을 정렬하여 가장 인기 있는 검색어 k개를 찾는다 : **O(clogc)**


![alt text](/images/image-1.png)
-> ```O(p)+O(c)+O(clogc)```
- 최악의 경우, k개 결과를 얻으려고 전체 트라이를 다 검색해야 하는 일 발생할 수 O 

<br/>
✔️ 해결 방안

**a. 접두어의 최대 길이 제한**
  - p값은 작은 정수값 -> "접두어 노드를 찾는" 단계의 시간 복잡도 : ```O(p)=O(작은 정수 값)=O(1)```


**b. 각 노드에 인기 검색어를 캐시** 
  - 각 노드에 k개의 인기 검색어를 저장 -> 전체 트라이를 검색하는 일 방지 O
  - 빠른 응답속도 & 저장할 공간 많이 필요
![alt text](/images/image-2.png)


```
a. 접두어 노드를 찾는 시간 복잡도는 O(1)로 바뀐다.
b. 최고 인기 검색어 5개를 찾는 질의의 시간 복잡도는 O(1)로 바뀐다. 검색 결과가 이미 캐시되어 있다. 
```

2. **데이터 수집 서비스**
![alt text](/images/image-3.png)
  
- ```데이터 분석 서비스 로그```
  = 검색창에 입력된 질의에 관한 원본 데이터가 보관됨. 새로운 데이터가 추가되고 인덱스를 걸지 않는다
  
- ```로그 취합 서버```
  = 데이터를 잘 취합하여 우리 시스템이 쉽게 소비할 수 있도록 함 
  - 데이터 취합의 실시간성

- ```취합된 데이터```
![alt text](/images/image-4.png) 

- ```작업 서버```
  - 주기적으로 비동기적 작업을 실행하는 서버 작업. 트라이 자료구조를 만들고 트라이 데이터베이스에 저장하는 역할
  
- ```트라이 캐시```
  - 분산 캐시 시스템
  - 트라이 데이터를 메모리에 유지하여 읽기 연산 성능을 높이는 구실

- ```트라이 데이터베이스```
  - 지속성 저장소
  
  a. 문서 저장소 : 새 트라이를 매주 만들 것이므로 주기적으로 트라이를 직렬화하여 데이터베이스에 저장할 수 있음 
  b. 키-값 저장소 
    - 트라이에 보관된 모든 접두어를 해시 테이블 키로 변환
    - 각 트라이 노드에 보관된 모든 데이터를 해시 케이블 값으로 변환
![alt text](/images/image-5.png)