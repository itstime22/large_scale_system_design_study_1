# 7장. 분산 시스템을 위한 유일ID 생성기 설계

- 기존의 ```auto_increment``` 방식은 사용 불가
  - 데이터베이스 서버 한 대 만으로는 그 요구를 감당할 수 X
  - 여러 데이터베이스 서버를 쓰는 경우에는 시간 지연(delay)를 낮추기가 매우 힘듦

---
  
### 1단계: 문제 이해 및 설계 범위 확정
- ID는 유일해야 함
- ID는 숫자로만 구성되어야 함
- ID는 64비트로만 표현될 수 있는 값이어야 함
- ID는 발급 날짜에 따라 정렬 가능해야 함
- 초당 10,000개의 ID를 만들 수 있어야 함 


### 2단계: 개략적 설계안 제시 및 동의 구하기
- 분산 시스템에서 유일성이 보장되는 ID를 만드는 다양한 방법

1.  ```다중 마스터 복제```
![alt text](image.png)
- auto_increment 기능 활용 -> ```k만큼 증가```
(k=현재 사용중인 데이터베이스 서버의 수)
- 단점
  - 여러 데이터 센터에 걸쳐 규모를 늘리기 어려움
  - 시간 흐름에 맞추어 커지도록 보장할 수 없음
  - 서버를 추가/삭제할 때도 잘 동작하도록 만들기 어려움 

<br/>

2. ```UUID```
= 컴퓨터 시스템에 저장되는 정보를 유일하게 식별하기 위한 128비트짜리 수
![alt text](image-1.png) 
- 웹 서버는 별도의 ID 생성기를 사용해 독립적으로 ID를 만들어냄 
- 장점
  - 서버 사이의 조율 필요 X -> 동기화 이슈 X
  - 각 서버가 자기가 쓸 ID를 알아서 만드는 구조 -> 규모 확장 쉬움
- 단점
  - ID가 128비트로 길다(우리의 조건 만족 X)
  - 시간순 정렬X
  - 숫자가 아닌 값이 포함될 수 있음

<br/>

3. ```티켓서버```
![alt text](image-2.png)
- auto_increment 기능을 갖춘 데이터베이스 서버(=티켓 서버)를 중앙 집중형으로 하나만 사용
- 장점
  - 유일성이 보장되는 오직 숫자로만 구성된 ID
  - 구현 쉬움. 중소 규모 애플리케이션에 적합.
- 단점
  - 티켓 서버가 SPOF(Single-Point-Of-Failure)가 될 수 있음 
  
<br/>

4. ```트위터 스노플레이크 접근법```
    ![alt text](image-3.png)
    - 생성해야 하는 ID의 구조를 여러 section으로 분할
    - **sign 비트** : 1비트. 음수와 양수 구별
    - **timestamp** : 41비트. 기원 시각 이후로 몇 millisecond 경과했는지
    - **데이터센터 ID** : 5비트. 2^5=32개 데이터센터를 지원 
    - **서버 ID** : 5비트. 한 데이터 센터당 32개의 서버 사용 가능
    - **일련 번호** : 12비트. ID를 생성할 때마다 일련번호 1만큼 증가. 1밀리초가 경과할때마다 0으로 초기화됨.

### 3단계: 상세 설계
> **스노우플레이크** 사용

- 데이터센터 ID, 서버 ID : 시스템이 시작할 때 결정. 일반적으로 운영 중에는 바뀌지 않는다
- 타임 스탬프, 일련 번호 : ID 생성기가 돌고 있는 중에 만들어지는 값 

<br/><br/>

**```타임스탬프```**
= 시간에 따라 점점 큰 값 -> 시간 정렬 가능
- 이진 표현 형태로부터 UTC 시각 추출
  (역으로 적용함면 어떤 UTC 시각도 상술한 타임스탬프 값으로 변환 가능)
![alt text](image-4.png)


- 41비트로 표현할 수 있는 최댓값=2^41-1=69년동안 정상 작동
- 기원 시각을 현재에 가깝게 맞춰서 오버플로가 발생하는 시점을 늦춰 놓은 것 
- 69년이 지나면
  - a. 기원 시각을 바꾸거나
  - b. ID 체계를 다른 것으로 이전해야 
<br/><br/>



**```일련번호```**
- 어떤 서버가 같은 밀리초 동안 하나 이상의 ID를 만들어 낸 경우에만 0보다 큰 값을 갖게 됨 

<br/><br/>
### 추가

```시계 동기화```
- 서버 별로 다른 시계를 사용한다면? 
  - 하나의 서버가 여러 코어에서 실행될 경우
  - 여러 서버가 물리적으로 독립된 여러 장비에서 실행되는 경우
- **NTP(Network Time Protocol)**이 문제를 해결하는 가장 보편적 수단

<br/>

```각 section 길이 최적화``` 
- (ex.) 동시성이 낮고 수명이 긴 애플리케이션 -> 일련번호 절의 길이를 줄이고 타임스탬프 절의 길이를 늘리는 것 

<br/>

```고가용성``` : ID 생성기는 필수 불가결 컴포넌트 -> 아주 높은 가용성을 제공


<br/><br/>

# 8장. URL 단축기 설계
### 1단계. 문제 이해 및 설계 범위 확장
> 1. URL 단축
> 2. URL 리디렉션
> 3. 높은 가용성, 규모 확장성, 장애 감내 요구됨

### 2단계. 개략적 설계안 제시 및 동의 구하기
1. ```API 엔드포인트```
   
   a. URL 단축용 엔드포인트 : 클라이언트가 엔드포인트에 단축할 URL을 인자로 실어서 POST 요청을 보냄
   b. URL 리디렉션용 엔드포인트 : 단축 URL에 대해서 HTTP 요청이 오면 원래 URL로 보내주기 위한 용도의 엔드포인트

<br/>

2. ```URL 리디렉션```
= 브라우저에 단축 URL을 입력하면 발생하는 일

![alt text](image-5.png)
- 단축 URL을 받은 서버 -> 단축 URL을 원래 URL로 바꿈 -> 301 응답의 Location 헤더에 넣어 반환
- **301 permanently moved** 
  - 해당 URL에 대한 HTTP 요청의 처리 책임이 영구적으로 Location 헤더에 반환된 URL로 이전되었다는 응답 
  - 브라우저는 **해당 응답을 캐시** ➡️ 추후 같은 단축 URL에 요청을 보낼 필요가 있을 때 브라우저는 **캐시된 원래 URL**로 요청을 보내게 됨 
  - ✔️ 서버 부하를 줄일 수 O

- **302 Found**
  - 주어진 URL로의 요청이 일시적으로 Location 헤더가 지정하는 URL에 의해 처리되어야 한다는 응답 
  - 언제나 단축 URL 서버에 먼저 보내진 후에 원래 URL로 리디렉션 
  - ✔️ 트래픽 분석이 중요할 때 : 클릭 발생률, 발생위치 추적


- **해시 테이블** : URL 리디렉션을 구현하는 가장 직관적인 방법
  - ```<단축 URL, 원래 URL>```


> 원래 URL=hashTable.get(단축 URL)
> 301 or 302 응답 Location 헤더에 원래 URL을 넣은 후 전송

<br/><br/>

### 3단계. 상세 설계

**```데이터 모델```**
- 모든 것을 해시테이블에 두면 안됨 : 메모리는 유한하고 비싸기 때문
![alt text](image-6.png)
- <단축 URL,원래 URL> 의 순서쌍을 **관계형 데이터베이스**에 저장하는 방식
---

```해시 함수```
1. **해시 값 길이**
- hashValue=[0-1,a-z,A-Z] 의 문자들로 구성됨 -> 총 10+26+26=**62개의 문자 사용 가능**
- hashValue의 길이를 정하기 위해서는 62^n>=3650억의 **n의 최솟값**을 찾아야 함 
![alt text](image-7.png)

2. **해시 후 충돌 해소**
- 잘 알려진 해시 함수 : CRC32,MD5,SHA-1 같은 것들 이용
![alt text](image-8.png)
- 모두 7자리가 넘는다..!! 

> **```해결 방안```**
> <br/>
a. **계산된 해시 값에서 처음 7개 글자만 이용**
    ➡️ 해시 결과가 서로 충돌할 확률 높아짐.
> - ✔️ 충돌이 실제로 발생했을 때는 충돌이 해소될 때까지 사전에 정한 문자열을 해시값에 덧붙임
> ![alt text](image-9.png)