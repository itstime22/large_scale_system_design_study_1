# 7장 분산시스템

## 'auto_increment 속성이 설정된 관계형 데이터 베이스의 기본 키를 쓰면 안되는 이유

**1. 단일 데이터베이스의 성능 한계**

- 여러개의 서버의 요청이 하나의 db에 집중
- INSERT를 예로들면 단일 MySQL의 auto_increment 락을 기다려야 함

```jsx
[애플리케이션 서버 10대]
         ↓
    [MySQL 1대]  ← auto_increment ID 발급
         ↓
INSERT 요청이 모두 여기로 집중
```

**2. 여러 데이터베이스를 쓰는 경우의 문제**

- DB가 독립적으로 auto_increment
    - 데이터 통합 조회
    - 데이터 마이그레이션 시 문제 발생
        - ex. DB 통합 작업 (부산 DB를 서울 DB로 이전)

```jsx
[서울 MySQL] - orders: id 1, 2, 3...
[부산 MySQL] - orders: id 1, 2, 3...  ← ID 충돌!
[대구 MySQL] - orders: id 1, 2, 3...  ← ID 충돌!
```

- increment 간격 설정
    - DB 추가/제거 시 설정 변경 어려움
    - ID 공간 낭비 (서울 DB가 죽으면 짝수 ID 영구 결번)

    ```jsx
    -- 부산 DB: 1, 3, 5, 7...
    SET @@auto_increment_increment = 2;
    SET @@auto_increment_offset = 1;
    
    -- 서울 DB: 2, 4, 6, 8...
    SET @@auto_increment_increment = 2;
    SET @@auto_increment_offset = 2;
    ```

- 중앙 집중식 ID 서버 (지연시간 증가)

```jsx
[부산 사용자] 
    ↓ 주문 생성 요청
[부산 애플리케이션 서버]
    ↓ 
    ❌ 가까운 부산 DB 사용 불가 (ID 충돌 가능성)
    ↓ 
    네트워크 왕복 400km
    ↓
[서울 중앙 DB - auto_increment]  ← 유일한 ID 발급처
    ↓
    네트워크 왕복 400km  
    ↓
[부산 애플리케이션 서버]
    ↓
[부산 DB에 데이터 저장]

// 물리적 거리 때문에 20-50ms 추가 지연
```

## 분산 시스템에서 유일성이 보장되는 ID를 만드는 방법

- 다중 마스터 복제(multi-master replication)
- UUID(Universally Unique Identifier)
- 티켓 서버 (ticket server)
- 트위터 스노플레이크(twitter snowflake)

### 다중 마스터 복제

auto_increment 기능을 활용하되 ID의 값을 구할 때 1만큼 증가시켜 얻는 것이 아니라, k만큼 증가

다만, 단점도 있는데

- 여러 데이터 센터에 걸쳐 규모를 늘리기 어렵다는 점

```jsx
// 한국: 2대 (increment=2)
서울 DB1: 1, 3, 5, 7, 9...
부산 DB2: 2, 4, 6, 8, 10...

// 미국 서버 추가(increment를 4로 변경 필요)

미국 DB3: 3, 7, 11, 15...  (offset=3, increment=4)
미국 DB4: 4, 8, 12, 16...  (offset=4, increment=4)

// 문제: 서울 DB1이 이미 7, 11을 사용해서 충돌 발생 
// 기존의 데이터 ID는 이미 시스템 곳곳에서 참조되고 있기 때문에 바꾸기가 어려움 
```

ID의 유일성은 보장되겠지만 그 값이 시간 흐름에 맞추어 커지도록 보장할 수는 없는 점

```jsx
// 2대 DB 운영 중
DB1 (홀수): 1, 3, 5, 7, 9...
DB2 (짝수): 2, 4, 6, 8, 10...

// 시간순 주문 발생
10:00:00 - DB2에서 주문 생성 → id: 100
10:00:01 - DB1에서 주문 생성 → id: 99   ← 더 나중인데 ID가 작음
10:00:02 - DB2에서 주문 생성 → id: 102
10:00:03 - DB1에서 주문 생성 → id: 101  ← 더 나중인데 ID가 작음
```

서버를 추가하거나 삭제할 때도 잘 동작하도록 만들기 어려운 점

```jsx
// 서버 추가 시 
// 2대 운영중
DB1: 1,3,5,7
DB2: 2,4,6,8

// DB3 추가
// increment 3으로 변경
DB1: 1, 4, 7, 10, 13, 16, 19...
DB2: 2, 5, 8, 11, 14, 17, 20...
DB3: 3, 6, 9, 12, 15, 18, 21...

// 문제 : 이미 기존 DB에 3, 5, 7, 9, 11, 13, 15가 발급되어 있어서 
// 새로운 DB3에서 발급하려는 키와 충돌
```

```jsx
//서버 삭제 시 
//3대 운영중
DB1: 1, 4, 7, 10, 13...
DB2: 2, 5, 8, 11, 14...
DB3: 3, 6, 9, 12, 15...

// DB2 장애로 제거
// increment를 2로 다시 변경

DB1: 1, 3, 5, 7, 9...
DB3: 3, 5, 7, 9, 11...  ← DB1과 겹침

// 또는 그냥 2개로 운영?
DB1: 1, 4, 7, 10, 13...  (increment=3 유지)
DB3: 3, 6, 9, 12, 15...  (increment=3 유지)

// 문제: 2, 5, 8, 11, 14... 범위가 영구 결번
// ID 공간의 33%를 낭비
```

## UUID

정보를 유일하게 식별하기 위한 128비트짜리 수

- 장점
    - 서버 사이의 조율이 필요 없으므로 동기화 이슈도 없음
    - 각 서버가 자기가 쓸 ID를 알아서 만드는 구조이므로 규모 확장이 쉬움
- 단점
- ID가 128비트로 김
- ID를 시간순으로 정렬할 수 없다
- ID에 숫자(numeric) 아닌 값이 포함될 수 있다

## 티켓서버

핵심은 auto_increment 기능을 갖춘 데이터베이스 서버, 즉 티켓 서버를 중앙 집중형으로 하나만 사용

- 장점
    - 유일성이 보장되는 오직 숫자로만 구성된 ID를 쉽게 만들 수 있다.
    - 유일성이 보장되는 오직 숫자로만 구성된 ID를 쉽게 만들 수 있다.
- 단점
    - 티켓 서버가 SPOF(Single-Point-of-Failure)가 된다.

## 스노우 플레이크

생성해야 하는 ID의 구조를 여러 절(section)로 분할

- 사인비트
    - 음수, 양수 구분
- 타임스탬프
    - epoch 이후 몇 밀리초가 경과
- 데이터센터ID
- 서버ID
- 일련번호

# 8장 url 단축기

URL 단축기는 기본적으로 두 개의 엔드포인트를 필요로 한다.

1. URL 단축용 엔드포인트: 새 단축 URL을 생성하고자 하는 클라이언트는 이
   엔드포인트에 단축할 URL을 인자로 실어서 POST 요청을 보내야 한다

2. URL 리디리렉션용 엔드포인트: 단축 URL에 대해서 HTTP 요청이 오면 원래
   URL로 보내주기 위한 용도의 엔드포인트. 다음과 같은 형태를 띤다


브라우저에 단축 URL을 입력하면 서버는 그 URL을 원래 URL로 바꿔서 301 응답의 Location 헤더에 넣어 반환한다.

유의할 점은 301 응답과 302 응답의 차이이다.


서버 부하를 줄이는 것이 중요하다면 301 Permanent Moved를 사용하는 것이 좋다.

하지만 트래픽 분석(analytics)이 중요할 때는 302 Found를 쓰는 쪽이 클릭 발생률이나 발생 위치를 추적하는 데 좀 더 유리하다.

URL 리디렉션을 구현하는 가장 직관적인 방법은 해시 테이블을 사용하는 것이다.여기서 해시 값으로 대응시킬 해시 함수 fx를 찾아야 한다.


데이터 모델의 경우 메모리의 한계가 있으므로 <단축 URL, 원래 URL)의 순서쌍을
관계형 데이터베이스에 저장하는 방식이 좋다


해시 함수 구현에 쓰일 기술로는 두 가지 가 있는데 하나는 '해시후 충돌 해소' 방법이고, 다른 하나는 'base-62 변환'이다.

1. 해시 후 충돌 해소
    1. 손쉬운 방법은 CRC32, MD5, SHA-1같이 잘 알려진 해시 함수를 이용하
       는 것이지만 조건으로 해시값이 제한되면 문제가 생길 수 있다.
    2. 그래서 제한된 값까지만 해시값으로 사용하고 충돌이 발생하면 사전에 정한 문자열을 덧붙이는 방법으로 해결가능


   다만, 데이터베이스 질의를 해야 하므로 오버헤드가 존재, 블룸 필터를 사용하면 성능을 높일 수 있다

3. base-62 변환
    1. 수를 표현하기 위해 총 62개의 문자를 사용하는 진법, 0은 0으로, 9는 9로, 10은 a로, 11은 b로, ・・・ 35는 2로 표현