#5장

수평적 규모 확장성을 달성하기 위해서는 요청 또는 데이터를 서버에 균등하게 나누는 것이 중요하다. 안정 해시는 이 목표를 달성하기 위해 보편적으로 사용하는 기술이다.

- 해시 키 재배치 문제

  N개의 캐시 서버가 있다고 하자. 이 서버들에 부하를 균등하게 나누는 보편적 방법은 아래의 해시 함수를 사용하는 것이다.

  serverIndex=hash(key) % N (N은 서버의 개수이다)


이 방법은 서버 풀의 크기가 고정되어 있을때, 그리고 데이터 분포가 균등할 때는 잘 동작한다.

하지만 서버가 추가되거나 기존 서버가 삭제되면 문제가 생긴다. 예를 들어 1번 서버가 장애를 일으켜 동작을 중단했다고 하자. 그러면 서버 풀의 크기는 3으로 변한다. 그 결과로, 키에 대한 해시 값은 변
하지 않지만 나머지(%) 연산을 적용하여 계산한 서버 인덱스 값은 달라질 것이다.


장애가 발생한 1번 서버에 보관되어 있는 키 뿐만 아닌 대부분의 키가 재분배되었다. 1번 서버가 죽으면

대부분 캐시 클라이언트가 데이터가 없는 엉뚱한 서버에 접속하게 된다는 뜻이다. 그 결과로 대규모 캐시

미스(cache miss)가 발생하게 될 것이다. 안정 해시는 이 문제를 효과적으로 해결하는 기술이다.

-    안정 해시

안정 해시는 해시 테이블 크기가 조정될 때 평균적으로 오직 k/n개의 키만 재배치하는 해시 기술이다. 여기서 k는 키의 개수이고, n은 슬롯(slot)의 개수다. 이와는 달리 대부분의 전통적 해시 테이블은 슬롯의 수가 바뀌면 거의 대부분 키를 재배치한다

- 해시 공간과 해시 링

  SHA-1의 해시 공간(hash space) 범위는 0부터 2160-1까지라고 알려져 있다. 따라서 x0는 0, xn은 2160-1이며, 나머지 x1부터 xn-1까지는 그 사이의 값을 갖게 될 것이다

- 해시 서버와 키

  해시 서버 배치 예시


해시 키 배치 예시

- 서버 조회, 추가, 제거

  어떤 키가 저장되는 서버는, 해당 키의 위치로부터 시계 방향으로 링을 탐색해 나가면서 만나는 첫 번째 서버다.


이에 따라서버를 추가하더라도 키 가운데 일부만 재배치하면 된다

새로운 서버 4가 추가된 뒤에 key0만 재배치됨을 알 수 있다.


- 기본 구현법의 두가지 문제

  기본 구현법의 절차는 다음과 같다.

    - 서버와 키를 균등 분포(uniform distribution) 해시 함수를 사용해 해시 링에 배치한다.
    - 키의 위치에서 링을 시계 방향으로 탐색하다 만나는 최초의 서버가 키가 저장될 서버다.

  이 접근법에는 두 가지 문제가 있다. 서버가 추가되거나 삭제되는 상황을 감안하면 파티션(partition)의 크기를 균등하게 유지하는 게 불가능하다는 것이 첫번째 문제다. 여기서 파티션은 인접한 서버

  사이의 해시 공간이다.

  어떤 서버는 굉장히 작은 해시 공간을 할당 받고, 어떤 서버는 굉장히 큰 해시 공간을 할당 받는 상황이 가능하다는 것이다.

  그림 5-10은 sl이 삭제되는 바람에 s2의 파티션이 다른 파티션 대비 거의 두 배로 커지는 상황을 보여준다.

  두 번째 문제는 키의 균등 분포(uniform distribution)를 달성하기가 어렵다는 것이다


이 문제를 해결하기 위해 제안된 기법이 가상 노드(virtual node) 또는 복제(replica)라 불리는 기법이다.

- 가상 노드

  가상 노드(virtual node)는 실제 노드 또는 서버를 가리키는 노드로서, 하나의 서버는 링 위에 여러 개의 가상 노드를 가질 수 있다

  가상 노드의 개수를 늘리면 키의 분포는 점점 더 균등해진다. 표준 편차(stand-ard deviation)가 작아져서 데이터가 고르게 분포되기 때문이다

  100~200개의 가상 노드를 사용했을 경우 표준 편차 값은 평균의 5%(가상 노드가 200개인 경우)에서 10%(가상 노드가 100개인 경우) 사이다. 가상 노드의 개수를 더 늘리면 표준 편차의 값은 더 떨어진다. 그러나 가상 노드 데이터를 저장할 공간은 더 많이 필요하게 될 것이다.

  그러니 시스템 요구사항에 맞도록 가상 노드 개수를 적절히 조정해야 할 것이다

  재배치할 키 결정

  서버 4가 추가되었다고 하면 s3부터 S4 사이에 있는 키들을 s4로 재배치하여야 한다.

  반대로 서버 S1이 5-15와 같이 삭제되면 s1부터(삭제된 노드) 그 반시계 방향에 있는
  최초 서버 SO 사이에 있는 키들이 S2로 재배치되어야 한다.

- 정리

  이번 장에서는 안정 해시가 왜 필요하며 어떻게 동작하는지를 자세히 살펴보았다.

  안정 해시의 이점은 다음과 같다.

    - 서버가 추가되거나 삭제될 때 재배치되는 키의 수가 최소화된다.
    - 데이터가 보다 균등하게 분포하게 되므로 수평적 규모 확장성을 달성하기 쉽다
    - 핫스팟(hotspot) 키 문제를 줄인다. 특정한 샤드(shard)에 대한 접근이 지나치게 빈번하면 서버 과부하 문제가 생길 수 있다. 케이티 페리, 저스틴 비버,레이디 가가 같은 유명인의 데이터가 전부 같은 샤드에 몰리는 상황을 생각해보면 이해가 쉬울 것이다. 안정 해시는 데이터를 좀 더 균등하게 분배하므로 이런 문제가 생길 가능성을 줄인다.

# 6장
키-값 저장소(key-value store)는 키-값 데이터베이스라고도 불리는 비 관계형(non-relational) 데이터베이스이다. 이 저장소에 저장되는 값은 고유 식별자(identifier)를 키로 가져야 한다. 키와 값 사이의 이런 연결 관계를 "키값" 쌍(pair)이라고 지칭한다.

값은 키를 통해서만 접근할 수 있고 키는 일반 텍스트일 수도 있고 해시 값일 수도 있다. 성능상의
이유로, 키는 짧을수록 좋다.

값은 문자열일 수도 있고 리스트(list)일 수도 있고 객체(object)일 수도 있다. 키-값 저장소는 보통 값으로 무엇이 오든 상관하지 않는다.

널리 알려진 것으로는 아마존 다이나모, memcached, 레디스가 있다.

- 문제 이해 및 설계 범위 확정

  완벽한 설계란 없다. 읽기, 쓰기 그리고 메모리 사용량 사이에 어떤 균형을 찾고, 데이터의 일관성과 가용성 사이에서 타협적 결정을 내린 설계를 만들었다면 쓸만한 답안일 것이다. 이번 장에서는 다음 특성을 갖는 키-값 저장소를 설계해 볼 것이다.

    - 키값 쌍의 크기는 10KB 이하이다.
    - 큰 데이터를 저장할 수 있어야 한다.
    - 높은 가용성을 제공해야 한다. 따라서 시스템은 설사 장애가 있더라도 빨리 응답해야 한다.
    - 높은 규모 확장성을 제공해야 한다. 따라서 트래픽 양에 따라 자동적으로
    - 서버 증설/삭제가 이루어져야 한다.
    - 데이터 일관성 수준은 조정이 가능해야 한다.
    - 응답 지연시간(latency)이 짧아야 한다.
- 단일 서버 키-값 저장소
- 분산 키-값 저장소

  키-값 쌍을 여러 서버에 분산시키는 방법. 분산 시스템을 설계할 때는 cap 정리를 이해하고 있어야 한다.

    - cap 정리

      데이터 일관성(consistency), 가용성(availability), 파티션 감내(partition tolerance) 3가지를 동시에 만족하는 분산 시스템을 설계하는 것은 불가능하다.

        - 데이터 일관성
            - 분산 시스템에 접속하는 모든 클라이언트는 어떤 노드에 접속했느냐에 관계없이 언제나 같은 데이터를 보아야 한다.
        - 가용성
            - 분산 시스템에 접속하는 클라이언트는 일부 노드에 장애가 발생하더라도 항상 응답을 받을 수 있어야 한다.
        - 파티션 감내
            - 두 노드 사이에 통신 장애(파티션)가 발생해도 시스템은 계속 동작해야 한다.
        - cp 시스템
            - 데이터 불일치 문제를 해결하기 위해 쓰기 연산을 중단시키고 문제가 해결될때까지 오류를 반환
        - ap 시스템
            - 낡은 데이터를 반환할 위험이 있더라도 읽기 연산 허용
            - 문제가 없는 노드에 쓰기 연산을 허용하고 파티션 문제가 해결된 뒤에 새 데이터를 n3에 전송



- 시스템 컴포넌트
    - 데이터 파티션
    - 데이터 다중화(replication)
    - 일관성 (consistency)
    - 일관성 불일치 해소(inconsistency resolution)
    - 장애 처리
    - 시스템 아키텍처 다이어그램
    - 쓰기 경로(write path)
    - 읽기 경로(read path)

- 데이터 파티션

  대규모 앱의 경우 전체 데이터를 한 대 서버에 욱여넣는 것은 불가능하다.

  가장 단순한 해결책은 데이터를 작은 파티션들로 분할한 다음 여러 대 서버에 저장하는 것이다.

  데이터를 파티션 단위로 나눌 때는 2가지를 생각해야 한다.

    - 데이터를 여러 서버에 고르게 분산할 수 잇는가
    - 노드가 추가되거나 삭제될 때 데이터의 이동을 최소화할 수 있는가’

  이때 사용할 수 있는 방법 이 안정해시이다. 안정 해시를 사용하면 다음과 같은 이점이 있다.

    - 규모 확장 자동화auto scailing
        - 시스템 부하에 따라 서버가 자동으로 추가되거나 삭제
    - 다양성heterogeneity
        - 각 서버의 용량에 맞게 가상 노드 수 조정 가능, 즉 고성능 서버는 더 많은 가상 노드를 갖도록 설정 가능

- 데이터 다중화

  높은 가용성과 안정성을 확보하기 위해서는 데이터를 N개 서버에 비동기적으로 다중화할 필요가 있다.(n개 조절가능)

  이때 링을 돌면서 노드를 뽑되, 이미 선택한 물리 서버에 속한 vnode면 건너뛰어 서로 다른 물리 서버로 n개를 확보할때까지 진행

